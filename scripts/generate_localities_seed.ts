
import fs from 'fs';
import path from 'path';

const sourceFile = path.resolve(process.cwd(), 'docs/SSOT/Melbourne Councils Suburbs Council Reference.md');
const dbContent = fs.readFileSync(sourceFile, 'utf-8');

interface Locality {
    suburb: string;
    council: string;
    region: string;
    character: string;
    ux_label: string;
}

const localities: Locality[] = [];

// Rough parser state machine
const lines = dbContent.split('\n');
let currentRegion = '';
let currentCouncil = '';
let currentCharacter = '';
let currentUxLabel = '';
let currentSuburbs: string[] = [];

for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // 1. Detect Region (## Header)
    if (line.startsWith('## ') && line.includes('Municipalities')) {
        currentRegion = line.replace('## ', '').split(' Municipalities')[0].trim();
        continue;
    }

    // 2. Detect Council (### Header)
    if (line.startsWith('### ')) {
        currentCouncil = line.replace('### ', '').trim();
        // Reset per-council vars to avoid leaking
        currentCharacter = '';
        currentUxLabel = '';
        currentSuburbs = [];
        continue;
    }

    // 3. Detect Properties
    if (line.startsWith('**Suburbs:**')) {
        let fullList = line.replace('**Suburbs:**', '').trim();

        // Look ahead for continuation lines until we hit **Character** or empty line
        let j = i + 1;
        while (j < lines.length && !lines[j].includes('**Character:**') && !lines[j].startsWith('##')) {
            const nextLine = lines[j].trim();
            if (nextLine) fullList += ' ' + nextLine;
            j++;
        }

        currentSuburbs = fullList.split(',')
            .map(s => s.trim())
            .filter(Boolean)
            .filter(s => !s.startsWith('http') && !s.includes('Page ') && !s.match(/^\d{2}:\d{2}$/)); // Filter PDF artifacts

        i = j - 1; // Advance main loop
        continue;
    }

    if (line.startsWith('**Character:**')) {
        currentCharacter = line.replace('**Character:**', '').trim();
        continue;
    }

    if (line.startsWith('**Use in UX:**')) {
        currentUxLabel = line.replace('**Use in UX:**', '').replace(/"/g, '').trim();

        // This is usually the end of a block. Push data.
        if (currentCouncil && currentRegion && currentSuburbs.length > 0) {
            currentSuburbs.forEach(sub => {
                // Double check parsing didn't capture generic junk
                if (sub.length < 3) return;

                localities.push({
                    suburb: sub.split(' http')[0].trim(), // Remove any trailing URL junk
                    council: currentCouncil,
                    region: currentRegion,
                    character: currentCharacter,
                    ux_label: currentUxLabel
                });
            });
        }
    }
}

// Generate SQL
console.log(`-- Migration: Seed Localities from SSOT`);
console.log(`-- Generated by script based on "Melbourne Councils Suburbs Council Reference.md"`);
console.log(``);

console.log(`-- 1. Add Columns if missing`);
console.log(`ALTER TABLE public.localities ADD COLUMN IF NOT EXISTS character text;`);
console.log(`ALTER TABLE public.localities ADD COLUMN IF NOT EXISTS ux_label text;`);
console.log(``);

console.log(`-- 2. Upsert Data`);
console.log(`INSERT INTO public.localities (suburb_name, council_name, region, character, ux_label, postcode, state) VALUES`);

const values = localities.map(l => {
    // Escape single quotes
    const sub = l.suburb.replace(/'/g, "''");
    const council = l.council.replace(/'/g, "''");
    const region = l.region.replace(/'/g, "''");
    const char = l.character.replace(/'/g, "''");
    const ux = l.ux_label.replace(/'/g, "''");
    return `  ('${sub}', '${council}', '${region}', '${char}', '${ux}', NULL, 'VIC')`;
});

console.log(values.join(',\n'));
console.log(`ON CONFLICT (suburb_name) DO UPDATE SET`);
console.log(`  council_name = EXCLUDED.council_name,`);
console.log(`  region = EXCLUDED.region,`);
console.log(`  character = EXCLUDED.character,`);
console.log(`  ux_label = EXCLUDED.ux_label;`);
